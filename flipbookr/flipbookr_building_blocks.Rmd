---
title: "flipbookr building blocks"
subtitle: "what lies beneath"
author: "Gina Reynolds, December 2019"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: ["xaringan-themer.css", ninjutsu]
    nature:
      ratio: 16:10
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r setup}
library(flipbookr)
library(tidyverse)
knitr::opts_chunk$set(fig.width = 6, message = F, warning = F, comment = "", cache = F)
```

```{r xaringan_look}
xaringanthemer::mono_accent(
  code_highlight_color = "rgba(255, 211, 0, .35)",
  base_color = "#03418A")
```




---



We'll use the tidyverse packages to create a pipeline, and flipbookr to walk through the steps in this pipeline.

```{r}
library(tidyverse)
library(flipbookr)
```

The input code to be "flipbookified" is below:

```{r cars_plot, echo = T, eval = F, fig.height=5}
cars %>%  #BREAK          
  ggplot() +  
  aes(x = speed) + 
  aes(color = speed) + #BREAK2
  geom_rug() #BREAK
```


---

Let's first look at the result of using flipbookr to bring this code.

---

`r chunk_reveal("cars_plot")`



---

Now, lets look at some of the functions working in the background.


---

`r chunk_reveal("code_parsing_and_calculations")`


```{r, code_parsing_and_calculations, echo = F, eval = F}
# The name of the code chunk containing code to be flipped
"cars_plot" %>% 
  # return the code as text
  chunk_code_get() %>% 
  # parse that code into code, pipes, comments, etc
  code_parse() %>% 
  # calculate which lines to show for each frame
  parsed_calc_show(break_type = "user") %>% 
  # calculate highlighting that is needed for each frame
  shown_lines_calc_highlight(break_type = "user")
```


---

`r chunk_reveal("partial_code")`


```{r partial_code, echo = F, eval = F}
# from the parsed code 
# and using calc for which lines to display ...
"cars_plot" %>% 
  chunk_code_get() %>% 
  code_parse() %>% #REVEAL
  # ... return the code needed for each slide ...
  parsed_return_partial_code_sequence() -> #REVEAL
# ... save this list
code_seq #REVEAL
```





---


# Deliver the code into a presentation tool.  

We are using Xaringan, so we create a template for code chunks.

```{r xaringan_slides}
return_partial_chunks_template_code()
return_partial_chunks_template_output()
```

---

# The generic templates above...



---

## ... are used to create chunks of code and output displayed side-by-side

```{r}
chunk_expand(chunk_name = "cars_plot")
```


---

## ... or a series of slides that *just* display output or *just* display code 


```{r}
chunk_expand(num_breaks = 2, display_type = "code")
chunk_expand(num_breaks = 2, display_type = "output")
```




---

# The reveal asks for the chunks we've created to be evaluated, by using the knitr::knit() function. 

We've applied it above.  Let's just look at the function itself.  

```{r}
chunk_reveal
```

---

# Notes (points of vacillation)

I'm vacillating on the public function name still.  I thought about chunk_reveal, reveal, flipbookify, flipify.
Most recently, I was most excited about chunk_reveal, but the function will also work with the parsed and expanded code as an input, which I think is really cool, and makes the code nice and flexible a la Yihui here:  https://yihui.org/en/2018/11/two-roads/

Related, I'm a little nervous about code_seq argument.  What if code_seq is defined in the global environment? 
There is this interesting warning about this formulation: https://adv-r.hadley.nz/functions.html#default-arguments  

Probably the right (worry free) way is to set the default to NULL, and then do an if.null() inside the function where code_seq is defined. The one downside is that this is a little verbose, right?  num_breaks would also need to be adjusted in this way. 

Another point of waffling was the argument order.  What's really the main input, is it the expanded code, or is it the chunk name?  Which ever (I'm not sure) should be the first thing. It probably must be the chunk name, as this is the way people will most likely use the code, else there would be a lot of confusion for the user.  Still, I found it unsatisfying that you, can't then somehow pipe code into this final function. 


---


# Go to code [**here**](https://github.com/EvaMaeRey/flipbookr/blob/master/R/base_parse_reveal_xaringan.R)

https://github.com/EvaMaeRey/flipbookr/blob/master/R/base_parse_reveal_xaringan.R





```{css, eval = TRUE, echo = F}
.remark-code{line-height: 1.5; font-size: 60%}
```